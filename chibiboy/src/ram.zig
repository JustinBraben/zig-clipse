const std = @import("std");
const print = @import("std").debug.print;

const Cart = @import("cartridge.zig").Cartridge;

/// Sequence to start the gameboy
const BOOT = [0x100]u8{
    // prod memory
    0x31, 0xFE, 0xFF, // LD SP,$FFFE
    // enable LCD
    0x3E, 0x91, // LD A,$91
    0xE0, 0x40, // LDH [Mem::LCDC], A
    // set flags
    0x3E, 0x01, // LD A,$01
    0xCB, 0x7F, // BIT 7,A (sets Z,n,H)
    0x37, // SCF (sets C)
    // set registers
    0x3E, 0x01, // LD A,$01
    0x06, 0x00, // LD B,$00
    0x0E, 0x13, // LD C,$13
    0x16, 0x00, // LD D,$00
    0x1E, 0xD8, // LD E,$D8
    0x26, 0x01, // LD H,$01
    0x2E, 0x4D, // LD L,$4D
    // skip to the end of the bootloader
    0xC3, 0xFD, 0x00, // JP $00FD
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    0x00, 0x00,
    0x00,
    // this instruction must be at the end of ROM --
    // after these finish executing, PC needs to be 0x100
    0xE0, 0x50, // LDH 50,A (disable boot rom)
};

pub const RAM = struct {
    debug: bool,
    cart: *Cart,
    boot: [0x100]u8,
    data: [0xFFFF + 1]u8,

    pub fn init(cart: *Cart, debug_ram: bool) RAM {
        return .{
            .debug = debug_ram,
            .cart = cart,
            .boot = BOOT,
            .data = [_]u8{0} ** 0x10000,
        };
    }

    /// Get the value at specified address of ram
    pub fn get(self: *RAM, addr: u16) u8 {
        const val = self.data[addr];

        if (self.debug) {
            std.io.getStdOut().writer().print("ram[{X:0>4}] -> {X:0>2}\n", .{ addr, val }) catch return 0;
        }

        return val;
    }

    /// Set the value at specified address of ram
    pub fn set(self: *RAM, addr: u16, val: u8) void {
        if (self.debug) {
            std.io.getStdOut().writer().print("ram[{X:0>4}] <- {X:0>2}\n", .{ addr, val }) catch return;
        }

        self.data[addr] = val;
    }
};